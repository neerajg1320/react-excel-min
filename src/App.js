import * as React from 'react';
import {Routes, Route, redirect} from 'react-router-dom';
import {ReadWrapper} from "./fileReader/ReadWrapper";
import {useCallback, useEffect, useMemo, useRef, useState} from "react";
import {debug} from "./components/config/debug";
import {HomeLayout} from "./components/HomeLayout";
import {TallyWrapper} from "./tally/TallyWrapper";
import {Categories} from "./category/Categories";
import {TableBulk} from "@glassball/table";

import AppContext from "./AppContext";

const defaultGroups = [
  {
    name: "Direct Expenses"
  },
  {
    name: "Indirect Expenses"
  },
];

const defaultCategories = [
  {
    name: "Travel",
    group: "Indirect Expenses"
  },
  {
    name: "Salary",
    group: "Indirect Expenses"
  },
  {
    name: "Stationary",
    group: "Indirect Expenses"
  },
  {
    name: "Food",
    group: "Indirect Expenses"
  },
  {
    name: "Transport",
    group: "Indirect Expenses"
  },
  {
    name: "Cotton",
    group: "Direct Expenses"
  }
];


const App = () => {
  if (debug.lifecycle) {
    console.log(`Rendering <App>`);
  }

  const debugData = false;
  const debugLedgers = false;
  const debugCategories = true;

  useEffect(() => {
    if (debug.lifecycle) {
      console.log(`<App>: First render`);
    }

    return () => {
      if (debug.lifecycle) {
        console.log(`<App>: Destroyed`);
      }
    }
  }, []);

  // The App keeps a copy of data
  const [data, setData] = useState([]);
  const [ledgers, setLedgers] = useState([]);
  const [categories, setCategories] = useState(defaultCategories);
  const [groups, setGroups] = useState(defaultGroups);
  const [selectables, setSelectables] = useState(() => {
    return [
      {
        keyName: "group",
        choices: ["Direct Expenses", "Direct Incomes", "Indirect Expenses", "Indirect Incomes"]
      }
    ]
  });

  // The following two could be turned to refs
  const modifiedRows = useRef([]);
  const deletedRows = useRef([]);

  const tallySavedRef = useRef(false);


  // The App component just maintains a copy of data.
  // The modification are done in table and tally components.
  const handleDataChange = useCallback((data, updates, source) => {
    // console.log(`handleDataChange: source=${source} tallySaved=${tallySavedRef.current} data=`, data);

    let newData = data;

    // TBD: We can do the below asynchronously
    // In case it is a data modify or delete action

    if (source === "dataSourceFileReader") {
      const indices = data.map((item,index) => index);
      if (indices.length > 0) {
        // setModifiedRows(indices);
        tallySavedRef.current = false;
      }
    } else if (source === "dataSourceTable") {
        // For now we do nothing here.
      console.log(`handleDataChange:dataSourceTable updates=`, updates);
      modifiedRows.current = updates.modifiedRows;
      deletedRows.current = updates.deletedRows;
    } else if (source === "dataSourceTally") {
      // We can count the Tally Operations here. This will happen only if data is submitted to Tally
      // We should get the indices here and clear the modifiedRows
      // console.log(`handleDataChange: source:${source} updates=`, updates);

      const responseIds = updates[0].payload;

      // We need to be very careful here
      // We need to check if all responses are accounted
      if (responseIds.length > 0) {
        // clearMarkedRows();
        tallySavedRef.current = true;
      }

    } else {
      console.error(`handleDataChange: source '${source}' not supported`);
    }

    setData(newData);
  }, []);

  const handleLedgersChange = useCallback((ledgers) => {
    if (debugLedgers) {
      console.log(`App: handleLedgersChange:`, ledgers);
    }
    // setLedgers(ledgers);
    setSelectables((prev) => {
      const newSelectables = [
          ...prev.filter(selectable => selectable.keyName !== 'category'),
        {
          keyName: "category",
          choices: ledgers ? ledgers.map(ledger => ledger.name) : []
        }
      ];

      console.log(`handleLedgersChange: newSelectables=${JSON.stringify(newSelectables, null, 2)}`)
      return newSelectables;
    })
  }, []);

  const handleCategoriesChange = (categories) => {
    console.log(`App: handleCategoriesChange:`, categories);

    setCategories(categories);
  }

  // Currently we are not using the AppContext
  const appContext = {
    data,
    onDataChange: handleDataChange,
    ledgers,
    onLedgersChange: handleLedgersChange,
    tallySaved:tallySavedRef.current,
    modifiedRows: modifiedRows.current,
    deletedRows: deletedRows.current,
    // categories,
    // onCategoriesChange: handleCategoriesChange,
    // groups,
  }

  return (
    <AppContext.Provider value={appContext}>
      {/* We add voucherIds generated by tally */}
      <TallyWrapper >
        <Routes>
          <Route element={<HomeLayout />}>

            {/* Data read from excel file */}
            <Route index element={<ReadWrapper />} />

            {/* Transactions are categorized by user */}
            <Route
                path="transactions"
                element={
                  <TableBulk
                      data={data}
                      onDataChange={handleDataChange}
                      updateWithCommit={false}
                      {...{ledgers, categories, selectables}}
                  />
                } />

            {/* Category information added by user */}
            <Route
                path="categories"
                element={
                  <Categories
                      {...{categories, groups}}
                      onCategoriesChange={handleCategoriesChange}
                  />
                }
            />

            <Route path="*" element={<p>There's nothing here: 404!</p>} />
          </Route>
        </Routes>
      </TallyWrapper>
    </AppContext.Provider>
  );
};

export default App;
